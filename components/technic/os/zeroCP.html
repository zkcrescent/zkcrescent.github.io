<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>零拷贝 | zkcrescent 的木屋</title>
    <meta name="description" content="一个莫得感情的代码工具人">
    
    
    <link rel="preload" href="/assets/css/0.styles.5ba0d270.css" as="style"><link rel="preload" href="/assets/js/app.d08f3d44.js" as="script"><link rel="preload" href="/assets/js/2.6d9f343b.js" as="script"><link rel="preload" href="/assets/js/17.04a01f44.js" as="script"><link rel="prefetch" href="/assets/js/10.3bbecd87.js"><link rel="prefetch" href="/assets/js/11.487618fe.js"><link rel="prefetch" href="/assets/js/12.200c642d.js"><link rel="prefetch" href="/assets/js/13.ae3ee37f.js"><link rel="prefetch" href="/assets/js/14.85241ba4.js"><link rel="prefetch" href="/assets/js/15.a2e85adf.js"><link rel="prefetch" href="/assets/js/16.578f7787.js"><link rel="prefetch" href="/assets/js/18.1aa516f3.js"><link rel="prefetch" href="/assets/js/19.943b43ad.js"><link rel="prefetch" href="/assets/js/20.39e01331.js"><link rel="prefetch" href="/assets/js/21.cc2963a3.js"><link rel="prefetch" href="/assets/js/22.a353e419.js"><link rel="prefetch" href="/assets/js/23.700eb580.js"><link rel="prefetch" href="/assets/js/24.84ca5a80.js"><link rel="prefetch" href="/assets/js/25.f91b3b4c.js"><link rel="prefetch" href="/assets/js/3.814f06c8.js"><link rel="prefetch" href="/assets/js/4.22c92981.js"><link rel="prefetch" href="/assets/js/5.b1ba64d5.js"><link rel="prefetch" href="/assets/js/6.02609707.js"><link rel="prefetch" href="/assets/js/7.8fa0efca.js"><link rel="prefetch" href="/assets/js/8.4c81744d.js"><link rel="prefetch" href="/assets/js/9.322c0ae1.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5ba0d270.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="theme-container vuepress-theme-simple"><header class="header"><a href="/" title="一个莫得感情的代码工具人" class="site-name router-link-active">zkcrescent 的木屋</a><div style="clear: both"></div><div class="navbar"><span><a href="/components/technic/golang/main.html" class="navbar-item">GoLang 相关</a><!----></span><span><a href="/components/technic/os/main.html" class="navbar-item">OS 相关</a><!----></span><span><a href="/components/technic/store/main.html" class="navbar-item">存储相关</a><!----></span><span><a href="/components/technic/link.html" class="navbar-item">知识链接</a><!----></span><span><a href="/intro.html" class="navbar-item">关于</a><!----></span></div></header><section class="post-view"><div class="post-head"><h1 class="post-title">Zero Copy</h1><time datetime="9/9/2019" title="9/9/2019" pubdate="pubdate" class="post-date">
  1 year ago
</time></div><div class="content__default"><h1 id="零拷贝"><a href="#零拷贝" aria-hidden="true" class="header-anchor">#</a> 零拷贝</h1> <p>定义：指从内核空间到用户空间的拷贝次数为零</p> <h2 id="问题"><a href="#问题" aria-hidden="true" class="header-anchor">#</a> 问题</h2> <p>计算机中，应用程序通常会遇到将磁盘数据写入网络的情况，会造成<a href="/os/us&amp;ks.html">用户态和内核态</a> 的频繁切换，具体过程如下：</p> <ol><li>应用程序将要发送某个磁盘上的文件，发起系统调用（1次 用户态到内核态切换）</li> <li>内核态中将磁盘数据放入内核 buff （DMA (Direct Memeory Access)）</li> <li>再将内核 buff 放入应用程序 buff(2次 内核态到用户态) (CPU COPY)</li> <li>程序请求发送网络，将应用程序 buff中的数据写入 socket buff(3次 用户态到内核态)（CPU COPY）</li> <li>内核将socket buff 写入 nic(<a href="https://en.wikipedia.org/wiki/Network_interface_controller" target="_blank" rel="noopener noreferrer">Network interafce controller<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>) buff （DMA）</li> <li>返回应用程序继续执行(4次 用户态到内核态)</li></ol> <p>从上看出，整个过程出现两次中断，四次上下文切换，很明显，第二三四五步骤可以合并的话就可以减少很多不必要开的开销</p> <h2 id="sendfile"><a href="#sendfile" aria-hidden="true" class="header-anchor">#</a> sendFile</h2> <p>从内核 2.1 开始，引入该方法，可以实现以下过程：</p> <ol><li>应用程序将要发送某个磁盘上的文件，发起系统调用（1次 用户态到内核态切换）</li> <li>内核态将磁盘数据放入内核 buff （DMA）</li> <li>将内核 buff 中的数据放入 socket buff （CPU COPY）</li> <li>将soket buff 数据拷贝到 nic buff（DMA）</li> <li>返回应用程序</li></ol> <p>从上可以看出，过程简化为一次中断，3次拷贝，两次上下文切换</p> <h2 id="scatter-gather-sendfile"><a href="#scatter-gather-sendfile" aria-hidden="true" class="header-anchor">#</a> scatter-gather sendFile</h2> <p>2.4 后的内核有了这个，可以只复制kernal buff少量元信息的基础上，直接将 kernal buff 复制到 nic buff 中，过程就变成了：</p> <ol><li>应用程序将要发送某个磁盘上的文件，发起系统调用（1次 用户态到内核态切换）</li> <li>内核态将磁盘数据放入内核 buff （DMA）</li> <li>将内核 buff 数据在内核 buff 中的位置(offset)和数据大小(size)追加到socket buff</li> <li>nic buff 通过 socket buff 中的offset 和 size 直接从内核 buff 中拷贝(DMA)</li> <li>返回应用程序</li></ol> <p>两次DMA COPY，很快</p> <h2 id="其他相关"><a href="#其他相关" aria-hidden="true" class="header-anchor">#</a> 其他相关</h2> <h3 id="mmap"><a href="#mmap" aria-hidden="true" class="header-anchor">#</a> MMAP</h3> <p>内存映射文件，将文件映射到进程的地址空间，实现物理地址和进程空间地址的对应</p> <p>进程可以向访问内存一样访问这个文件，而不需要通过read， write
当 kernal buff 和 app buff 共用这个文件时，可以实现零拷贝</p> <h4 id="优势"><a href="#优势" aria-hidden="true" class="header-anchor">#</a> 优势</h4> <ul><li>多进程访问时节约内存空间</li> <li>数据在内核中，可以直接发送到网络，而应用程序无法修改数据（保护数据）</li></ul> <h4 id="劣势"><a href="#劣势" aria-hidden="true" class="header-anchor">#</a> 劣势</h4> <ul><li>当映射文件写入，用时被另一个进程切断，可能被总线错误信号SIGBUS中断，而这个信号意味着KILL PROCESS或者DUMP CORE，对服务来说不可接受</li> <li>访问多个小文件时，不如 send file 高效</li></ul></div><div class="list-item"><div class="divider"></div><div class="post-footer">&lt;- back</div><div class="post-footer">&lt;- back to home</div></div></section><footer class="footer">
  © 2021
  <!---->
  
  <br>
  Powered by
  <a href="https://vuepress.vuejs.org/" rel="noopener" target="_blank">VuePress</a>
  | Theme, Customized from
  <a href="https://github.com/viko16/vuepress-theme-simple" rel="noopener" target="_blank">Simple</a></footer></div><!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d08f3d44.js" defer></script><script src="/assets/js/2.6d9f343b.js" defer></script><script src="/assets/js/17.04a01f44.js" defer></script>
  </body>
</html>
