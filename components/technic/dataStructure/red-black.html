<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>红黑树 | zkcrescent 的木屋</title>
    <meta name="description" content="一个莫得感情的代码工具人">
    
    
    <link rel="preload" href="/assets/css/0.styles.5ba0d270.css" as="style"><link rel="preload" href="/assets/js/app.52eaae7e.js" as="script"><link rel="preload" href="/assets/js/2.6d9f343b.js" as="script"><link rel="preload" href="/assets/js/8.74172104.js" as="script"><link rel="prefetch" href="/assets/js/10.21abb8b0.js"><link rel="prefetch" href="/assets/js/11.50f2c43c.js"><link rel="prefetch" href="/assets/js/12.26a02888.js"><link rel="prefetch" href="/assets/js/13.79df7d96.js"><link rel="prefetch" href="/assets/js/14.cd7ca4fd.js"><link rel="prefetch" href="/assets/js/15.0b5572e4.js"><link rel="prefetch" href="/assets/js/16.b849a9fe.js"><link rel="prefetch" href="/assets/js/17.9ebfd29d.js"><link rel="prefetch" href="/assets/js/18.1423e777.js"><link rel="prefetch" href="/assets/js/19.4815dfb7.js"><link rel="prefetch" href="/assets/js/20.367539e2.js"><link rel="prefetch" href="/assets/js/21.f0ad3303.js"><link rel="prefetch" href="/assets/js/22.d8d03564.js"><link rel="prefetch" href="/assets/js/23.81f497ef.js"><link rel="prefetch" href="/assets/js/24.000e4ca0.js"><link rel="prefetch" href="/assets/js/25.a6cc947f.js"><link rel="prefetch" href="/assets/js/26.971ebe23.js"><link rel="prefetch" href="/assets/js/27.7f12229e.js"><link rel="prefetch" href="/assets/js/28.d0316184.js"><link rel="prefetch" href="/assets/js/3.814f06c8.js"><link rel="prefetch" href="/assets/js/4.da136bfd.js"><link rel="prefetch" href="/assets/js/5.d8996a38.js"><link rel="prefetch" href="/assets/js/6.24a1903b.js"><link rel="prefetch" href="/assets/js/7.9f0f5d1d.js"><link rel="prefetch" href="/assets/js/9.55e18633.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5ba0d270.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="theme-container vuepress-theme-simple"><header class="header"><a href="/" title="一个莫得感情的代码工具人" class="site-name router-link-active">zkcrescent 的木屋</a><div style="clear: both"></div><div class="navbar"><span><a href="/components/technic/golang/main.html" class="navbar-item">GoLang 相关</a><!----></span><span><a href="/components/technic/os/main.html" class="navbar-item">OS 相关</a><!----></span><span><a href="/components/technic/store/main.html" class="navbar-item">存储相关</a><!----></span><span><a href="/components/technic/dataStructure/main.html" class="navbar-item">数据结构</a><!----></span><span><a href="/components/technic/link.html" class="navbar-item">知识链接</a><!----></span><span><a href="/intro.html" class="navbar-item">关于</a><!----></span></div></header><section class="post-view"><div class="post-head"><h1 class="post-title">红黑树</h1><time datetime="8/10/2021" title="8/10/2021" pubdate="pubdate" class="post-date">
  14 seconds ago
</time></div><div class="content__default"><h2 id="红黑树"><a href="#红黑树" aria-hidden="true" class="header-anchor">#</a> 红黑树</h2> <h3 id="介绍"><a href="#介绍" aria-hidden="true" class="header-anchor">#</a> 介绍</h3> <p>红黑树，Red-Black Tree 「RBT」是一个自平衡二叉查找树(BST)，树上的每个节点都遵循下面的规则:</p> <ol><li>每个节点都有红色或黑色</li> <li>树的根始终是黑色的</li> <li>没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点）</li> <li>从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点</li></ol> <h3 id="插入"><a href="#插入" aria-hidden="true" class="header-anchor">#</a> 插入</h3> <h4 id="重标记颜色"><a href="#重标记颜色" aria-hidden="true" class="header-anchor">#</a> 重标记颜色</h4> <p>假设插入的新节点为 X</p> <ol><li>将新插入的节点标记为红色</li> <li>如果 X 是根结点(root)，则标记为黑色</li> <li><code>如果 X 的 parent 不是黑色 且 X 的 uncle (叔叔) 是红色</code></li></ol> <ul><li>3.1 将 parent 和 uncle 标记为黑色</li> <li>3.2 将 grand parent (祖父) 标记为红色</li> <li>3.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li></ul> <p>（X 的 parent 不可能同时是红色又是 root (步骤二确定root一定是黑色)）</p> <h4 id="举例"><a href="#举例" aria-hidden="true" class="header-anchor">#</a> 举例</h4> <p><img src="/img/RBT-recolor.png" alt="EXAMPLE"></p> <ul><li>将新插入的 X 节点标记为红色</li> <li>发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」</li> <li>发现 X 的 uncle (U) 同样为红色</li> <li>将 P 和 U 标记为黑色</li> <li>将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，将 G 做为新的 X，继续重复公式 2、3</li> <li>发现 G 是根结点，标记为黑色</li></ul> <h4 id="旋转"><a href="#旋转" aria-hidden="true" class="header-anchor">#</a> 旋转</h4> <p><code>如果 X 的 parent 不是黑色 且 X 的 uncle (叔叔) 是黑色</code></p> <ul><li>左左</li></ul> <p><img src="/img/RBT-ll.png" alt="EXAMPLE"></p> <p>将 X 的 parent P 和 祖父 G 交换, 将 G 作为 P 的右节点， P 原本的右节点作为祖父的左节点, 即 P.right, G.left = G, P.right;</p> <ul><li>左右</li></ul> <p><img src="/img/RBT-lr.png" alt="EXAMPLE"></p> <p>先将 P 和 X 交换， P 作为 X 的左节点, X 原本的左节点作为P的右节点, 即 X.left, P.right = P, X.left</p> <p>然后使用左左的规则</p> <ul><li>右右类似左左</li></ul> <p><img src="/img/RBT-rr.png" alt="EXAMPLE"></p> <ul><li>右左类似左右</li></ul> <p><img src="/img/RBT-rl.png" alt="EXAMPLE"></p> <h3 id="删除"><a href="#删除" aria-hidden="true" class="header-anchor">#</a> 删除</h3></div><div class="list-item"><div class="divider"></div><div class="post-footer">&lt;- back</div><div class="post-footer">&lt;- back to home</div></div></section><footer class="footer">
  © 2021
  <!---->
  
  <br>
  Powered by
  <a href="https://vuepress.vuejs.org/" rel="noopener" target="_blank">VuePress</a>
  | Theme, Customized from
  <a href="https://github.com/viko16/vuepress-theme-simple" rel="noopener" target="_blank">Simple</a></footer></div><!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.52eaae7e.js" defer></script><script src="/assets/js/2.6d9f343b.js" defer></script><script src="/assets/js/8.74172104.js" defer></script>
  </body>
</html>
