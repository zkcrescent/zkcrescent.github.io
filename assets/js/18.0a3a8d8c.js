(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{256:function(e,t,a){"use strict";a.r(t);var r=a(38),_=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"零拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#零拷贝","aria-hidden":"true"}},[e._v("#")]),e._v(" 零拷贝")]),e._v(" "),a("p",[e._v("定义：指从内核空间到用户空间的拷贝次数为零")]),e._v(" "),a("h2",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 问题")]),e._v(" "),a("p",[e._v("计算机中，应用程序通常会遇到将磁盘数据写入网络的情况，会造成"),a("router-link",{attrs:{to:"/os/us&ks.html"}},[e._v("用户态和内核态")]),e._v(" 的频繁切换，具体过程如下：")],1),e._v(" "),a("ol",[a("li",[e._v("应用程序将要发送某个磁盘上的文件，发起系统调用（1次 用户态到内核态切换）")]),e._v(" "),a("li",[e._v("内核态中将磁盘数据放入内核 buff （DMA (Direct Memeory Access)）")]),e._v(" "),a("li",[e._v("再将内核 buff 放入应用程序 buff(2次 内核态到用户态) (CPU COPY)")]),e._v(" "),a("li",[e._v("程序请求发送网络，将应用程序 buff中的数据写入 socket buff(3次 用户态到内核态)（CPU COPY）")]),e._v(" "),a("li",[e._v("内核将socket buff 写入 nic("),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Network_interface_controller",target:"_blank",rel:"noopener noreferrer"}},[e._v("Network interafce controller"),a("OutboundLink")],1),e._v(") buff （DMA）")]),e._v(" "),a("li",[e._v("返回应用程序继续执行(4次 用户态到内核态)")])]),e._v(" "),a("p",[e._v("从上看出，整个过程出现两次中断，四次上下文切换，很明显，第二三四五步骤可以合并的话就可以减少很多不必要开的开销")]),e._v(" "),a("h2",{attrs:{id:"sendfile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sendfile","aria-hidden":"true"}},[e._v("#")]),e._v(" sendFile")]),e._v(" "),a("p",[e._v("从内核 2.1 开始，引入该方法，可以实现以下过程：")]),e._v(" "),a("ol",[a("li",[e._v("应用程序将要发送某个磁盘上的文件，发起系统调用（1次 用户态到内核态切换）")]),e._v(" "),a("li",[e._v("内核态将磁盘数据放入内核 buff （DMA）")]),e._v(" "),a("li",[e._v("将内核 buff 中的数据放入 socket buff （CPU COPY）")]),e._v(" "),a("li",[e._v("将soket buff 数据拷贝到 nic buff（DMA）")]),e._v(" "),a("li",[e._v("返回应用程序")])]),e._v(" "),a("p",[e._v("从上可以看出，过程简化为一次中断，3次拷贝，两次上下文切换")]),e._v(" "),a("h2",{attrs:{id:"scatter-gather-sendfile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scatter-gather-sendfile","aria-hidden":"true"}},[e._v("#")]),e._v(" scatter-gather sendFile")]),e._v(" "),a("p",[e._v("2.4 后的内核有了这个，可以只复制kernal buff少量元信息的基础上，直接将 kernal buff 复制到 nic buff 中，过程就变成了：")]),e._v(" "),a("ol",[a("li",[e._v("应用程序将要发送某个磁盘上的文件，发起系统调用（1次 用户态到内核态切换）")]),e._v(" "),a("li",[e._v("内核态将磁盘数据放入内核 buff （DMA）")]),e._v(" "),a("li",[e._v("将内核 buff 数据在内核 buff 中的位置(offset)和数据大小(size)追加到socket buff")]),e._v(" "),a("li",[e._v("nic buff 通过 socket buff 中的offset 和 size 直接从内核 buff 中拷贝(DMA)")]),e._v(" "),a("li",[e._v("返回应用程序")])]),e._v(" "),a("p",[e._v("两次DMA COPY，很快")]),e._v(" "),a("h2",{attrs:{id:"其他相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他相关","aria-hidden":"true"}},[e._v("#")]),e._v(" 其他相关")]),e._v(" "),a("h3",{attrs:{id:"mmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mmap","aria-hidden":"true"}},[e._v("#")]),e._v(" MMAP")]),e._v(" "),a("p",[e._v("内存映射文件，将文件映射到进程的地址空间，实现物理地址和进程空间地址的对应")]),e._v(" "),a("p",[e._v("进程可以向访问内存一样访问这个文件，而不需要通过read， write\n当 kernal buff 和 app buff 共用这个文件时，可以实现零拷贝")]),e._v(" "),a("h4",{attrs:{id:"优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优势","aria-hidden":"true"}},[e._v("#")]),e._v(" 优势")]),e._v(" "),a("ul",[a("li",[e._v("多进程访问时节约内存空间")]),e._v(" "),a("li",[e._v("数据在内核中，可以直接发送到网络，而应用程序无法修改数据（保护数据）")])]),e._v(" "),a("h4",{attrs:{id:"劣势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#劣势","aria-hidden":"true"}},[e._v("#")]),e._v(" 劣势")]),e._v(" "),a("ul",[a("li",[e._v("当映射文件写入，用时被另一个进程切断，可能被总线错误信号SIGBUS中断，而这个信号意味着KILL PROCESS或者DUMP CORE，对服务来说不可接受")]),e._v(" "),a("li",[e._v("访问多个小文件时，不如 send file 高效")])])])},[],!1,null,null,null);t.default=_.exports}}]);