(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{248:function(a,t,e){"use strict";e.r(t);var s=e(38),n=Object(s.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"在-golang-js-中-的-aes-256-gcm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-golang-js-中-的-aes-256-gcm","aria-hidden":"true"}},[a._v("#")]),a._v(" 在 golang & js 中 的 aes-256-gcm")]),a._v(" "),e("ul",[e("li",[a._v("编写时间： 2019-12-12（今天双十二呢-。 -")]),a._v(" "),e("li",[a._v("以下说到的 "),e("code",[a._v("gcm")]),a._v(" 均指 "),e("code",[a._v("aes-256-gcm")])])]),a._v(" "),e("h3",{attrs:{id:"来源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#来源","aria-hidden":"true"}},[a._v("#")]),a._v(" 来源")]),a._v(" "),e("p",[a._v("最近在做了一个基于 "),e("code",[a._v("aes-256-gcm")]),a._v(" 加密算法的Http通信，一开始 server, client 都是用golang写的, 引入同一个pkg，加解密没问题，后来\n改用 js 写 client, 用了原生的 "),e("code",[a._v("crypto")]),a._v(" pkg 做加解密，OK，问题前述就是这样")]),a._v(" "),e("h3",{attrs:{id:"中间过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中间过程","aria-hidden":"true"}},[a._v("#")]),a._v(" 中间过程")]),a._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[a._v("    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" cipher "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" crypto"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("createCipheriv")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'aes-256-gcm'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" iv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("p",[a._v("在 js 中, crypto 这个包在生成cipher的时候，传入三个参数，第一个是算法名，第二个是 key, gcm 中使用的是 "),e("code",[a._v("32 byte")]),a._v(", 早期的 aes-128-gcm 使用的是 "),e("code",[a._v("16 byte")]),a._v(", 中间还有个 aes-192-gcm\ngolang 的gcm返回值只有一个[]byte,而js的返回应该是两个，一个是 cipher.Update + cipher.final 的buff(text 加密结果) 以及 gcm 的tag，为了对比 golang 的结果排列顺序，传入同一个 iv,\n然后 print 结果的buff, 对比值，知道了 golang 的结果是 iv + encodedText +tag 返回的")]),a._v(" "),e("ul",[e("li",[a._v("中间遇到的一个小问题： golang 的 base64.RawStdEncoding 和 js 的base64 表象不一样， golang base64.StdEncoding = js base64 encode，所以一开始两边完成后加解密出现问题")]),a._v(" "),e("li",[a._v("问题二：在翻看 golang aes 源代码的时候， 发现结果的table是 256 长度的，一度误导了我以为golang 的 gcm 是 aes-256-gcm, 所以陷入了 怎么用 16 byte 的 key 做到 256的 -。 -，这是一个很弱智的问题，其实人家后面都是空位- -不过一开始在没有阅读aes算法的前提下确实让我走了好些弯路试图去理解这个")]),a._v(" "),e("li",[a._v("同时还学到了 golang simbbly 文件， "),e("code",[a._v("// go: noescape")]),a._v(" 这个 marker，虽然我不会写汇编和阅读汇编，至少让我了解了更多的关于 golang 的一些东西")])]),a._v(" "),e("h4",{attrs:{id:"相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相关","aria-hidden":"true"}},[a._v("#")]),a._v(" 相关")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://proprivacy.com/guides/aes-encryption",target:"_blank",rel:"noopener noreferrer"}},[a._v("aes"),e("OutboundLink")],1)])]),a._v(" "),e("h4",{attrs:{id:"思考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思考","aria-hidden":"true"}},[a._v("#")]),a._v(" 思考")]),a._v(" "),e("p",[a._v("中间虽然花费了较大的功夫去阅读元代码，但是让我对aes的了解就比单纯的看看文档理解多了很多，同时也间接的了解了golang中的一些小case, 还是学到了很多东西")])])},[],!1,null,null,null);t.default=n.exports}}]);