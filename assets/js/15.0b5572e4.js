(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{254:function(e,a,r){"use strict";r.r(a);var t=r(38),c=Object(t.a)({},function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"k8s-code-gen-kube-builder"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#k8s-code-gen-kube-builder","aria-hidden":"true"}},[e._v("#")]),e._v(" K8S code gen & kube builder")]),e._v(" "),r("h3",{attrs:{id:"code-gen"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#code-gen","aria-hidden":"true"}},[e._v("#")]),e._v(" code gen")]),e._v(" "),r("p",[e._v("这是一个从提供的SPEC自动帮助生成 "),r("code",[e._v("informer + deepcopyFile + clientset")]),e._v(" 的 k8s 标准 operator 的代码生成工具，可以减少用户去编写大量复杂繁琐的k8s interafce, 竟可能的将逻辑放在事件的处理上，但是\n即便如此，该工具生成的代码也需要关注很多K8S基础代码，包括WATCH,LIST资源，CREATE,UPdate，DELETE事件的函数绑定，OWNS 的手动注册等等，整体上来说，是很底层的K8S封装，只是解决了如何接入 K8S controller 体系 的问题，\n并没有做更上层的封装")]),e._v(" "),r("p",[e._v("代码分析参考官方示例即可")]),e._v(" "),r("h3",{attrs:{id:"kube-builder"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kube-builder","aria-hidden":"true"}},[e._v("#")]),e._v(" kube builder")]),e._v(" "),r("p",[e._v("对比 code gen 的更高级封装，通过"),r("code",[e._v("runtime")]),e._v(" pkg 暴露很多简易接口，包括连接配置，注册 kube spec(已生成的带有deepcopy能力的spec)，own objs， watch 的更高级抽象封装，"),r("code",[e._v("reconciler")]),e._v(" 作为其中的关键部分，是其中的核心价值，\n每一次有新的spec变动带来的事件触发时，reconciler 会给出该事件的req, 描述该事件的meta，同时可以通过 "),r("code",[e._v("runtime")]),e._v("的方法通过 req 获取到对应的资源细节，从而进行相关的CURD，对资源的更新删除操作亦或是提供了一个很简单的接口即可使用,\n在SPEC更新完成后，可以通过"),r("code",[e._v("make manifests")]),e._v("产出给出的spec的相关crd定义文件，spec的相关示例文件，对用户使用的spec编写对应crd定义文件繁琐易错这个问题上提供了极大地帮助，同时也封装了在kube集群中部署时的多实例部署，主备能力等")]),e._v(" "),r("h4",{attrs:{id:"kube-buidler-源代码主要pkg分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kube-buidler-源代码主要pkg分析","aria-hidden":"true"}},[e._v("#")]),e._v(" kube buidler 源代码主要pkg分析")]),e._v(" "),r("h5",{attrs:{id:"cmd"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cmd","aria-hidden":"true"}},[e._v("#")]),e._v(" /cmd")]),e._v(" "),r("p",[e._v("该目录下主要是 通过 "),r("code",[e._v("cobra")]),e._v(" 做的命令行工具，绑定一些相关属性到对应的生成器属性上")]),e._v(" "),r("h5",{attrs:{id:"pkg-scaffold"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pkg-scaffold","aria-hidden":"true"}},[e._v("#")]),e._v(" /pkg/scaffold")]),e._v(" "),r("p",[e._v("该 pkg 主要是定义了 "),r("code",[e._v("Scoflod")]),e._v(" 的 Interface 以及其工作时渲染文件的一个"),r("code",[e._v("template")]),e._v(" interafce 定义，scofold 上绑定了多个渲染框架(v1, v2)，每个框架下包括了多个 "),r("code",[e._v("template interface")]),e._v(", 通过给出渲染 "),r("code",[e._v("resource")]),e._v(" 将对应的实际template渲染输出")]),e._v(" "),r("h5",{attrs:{id:"pkg-scaffold-resource"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pkg-scaffold-resource","aria-hidden":"true"}},[e._v("#")]),e._v(" /pkg/scaffold/resource")]),e._v(" "),r("p",[e._v("定义传递给 "),r("code",[e._v("tempalate")]),e._v(" interface 的 "),r("code",[e._v("resource")])]),e._v(" "),r("h5",{attrs:{id:"pkg-scaffold-v1-pkg-scaffold-v2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pkg-scaffold-v1-pkg-scaffold-v2","aria-hidden":"true"}},[e._v("#")]),e._v(" /pkg/scaffold/v1 / /pkg/scaffold/v2")]),e._v(" "),r("p",[e._v("定义 v1, v2两个不同版本的大框架")]),e._v(" "),r("h5",{attrs:{id:"pkg-plugin"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pkg-plugin","aria-hidden":"true"}},[e._v("#")]),e._v(" /pkg/plugin")]),e._v(" "),r("p",[e._v("可以通过该pkg能将自己需要的一些模板渲染功能做相关的调整，但是目前没有可以从 cmd 层面直接更新 args 的方法，导致了在需要对 cmd 做增强的时候只能通过重写 cmd 的方法引入新的 cmd 能力")])])},[],!1,null,null,null);a.default=c.exports}}]);