(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{261:function(a,r,t){"use strict";t.r(r);var e=t(38),s=Object(e.a)({},function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"redis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis","aria-hidden":"true"}},[a._v("#")]),a._v(" redis")]),a._v(" "),t("h2",{attrs:{id:"通信协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通信协议","aria-hidden":"true"}},[a._v("#")]),a._v(" 通信协议")]),a._v(" "),t("p",[a._v("客户端与服务端使用的通信协议， 特点："),t("code",[a._v("实现简单，解析快，良好可读性")])]),a._v(" "),t("ul",[t("li",[t("code",[a._v("+")]),a._v(" 表示正确的状态，信息紧跟")]),a._v(" "),t("li",[t("code",[a._v("-")]),a._v(" 表示错误状态, 信息紧跟")]),a._v(" "),t("li",[t("code",[a._v("*")]),a._v(" 消息体有多少段")]),a._v(" "),t("li",[t("code",[a._v("$")]),a._v(" 下一行长度")]),a._v(" "),t("li",[t("code",[a._v(":")]),a._v(" 返回值，后面跟")])]),a._v(" "),t("h2",{attrs:{id:"数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构","aria-hidden":"true"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),t("ul",[t("li",[a._v("string(二进制安全，最大512M，原因（没有找到具体说明，纯属个人臆断）：可能是因为长度(bit)使用的u32定义，所以最大是2^32，512M)")]),a._v(" "),t("li",[a._v("list(链表，最大2^32-1个元素)")]),a._v(" "),t("li",[a._v("hash map")]),a._v(" "),t("li",[a._v("set(无序集合，hash 实现，数据唯一)")]),a._v(" "),t("li",[a._v("zset（有序集合，hash 实现，通过double类型的分数决定排位）")])]),a._v(" "),t("h2",{attrs:{id:"key-和-value-长度影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#key-和-value-长度影响","aria-hidden":"true"}},[a._v("#")]),a._v(" Key 和 Value 长度影响")]),a._v(" "),t("ul",[t("li",[a._v("均只能在512M以内(u32定义)")]),a._v(" "),t("li",[a._v("Key 最好不超过1024 字节，原因在于不仅内存资源占用更多，字符搜索和对比需要更多的时间")]),a._v(" "),t("li",[a._v("Key 特别短也不建议比如u100flw，建议使用可读性更好的Key, 比如 user:1000:followers")])]),a._v(" "),t("h2",{attrs:{id:"性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能","aria-hidden":"true"}},[a._v("#")]),a._v(" 性能")]),a._v(" "),t("p",[a._v("10W+ QPS")]),a._v(" "),t("p",[a._v("随连接数增加而降低")]),a._v(" "),t("h2",{attrs:{id:"持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#持久化","aria-hidden":"true"}},[a._v("#")]),a._v(" 持久化")]),a._v(" "),t("h3",{attrs:{id:"rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb","aria-hidden":"true"}},[a._v("#")]),a._v(" RDB")]),a._v(" "),t("p",[a._v("redis database, 默认方式，存储数据")]),a._v(" "),t("h3",{attrs:{id:"aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof","aria-hidden":"true"}},[a._v("#")]),a._v(" AOF")]),a._v(" "),t("p",[a._v("append only file, 根据条件将 aof_buf 中的缓存写入 aof 文件，再根据一定条件 调用 fsync 写入磁盘，存储 "),t("code",[a._v("通信协议")]),a._v(" 命令文本")]),a._v(" "),t("h3",{attrs:{id:"差异"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#差异","aria-hidden":"true"}},[a._v("#")]),a._v(" 差异")]),a._v(" "),t("ol",[t("li",[a._v("aof文件比rdb更新频率高，优先使用aof还原数据")]),a._v(" "),t("li",[a._v("aof比rdb更安全，但文件更大")]),a._v(" "),t("li",[a._v("rdb性能比aof好")]),a._v(" "),t("li",[a._v("如果两个都配了优先加载AOF")])]),a._v(" "),t("h2",{attrs:{id:"其他"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他","aria-hidden":"true"}},[a._v("#")]),a._v(" 其他")]),a._v(" "),t("h3",{attrs:{id:"一致性-hash-算法-（常用的hash-分片存储方式）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一致性-hash-算法-（常用的hash-分片存储方式）","aria-hidden":"true"}},[a._v("#")]),a._v(" 一致性 HASH 算法 （常用的HASH 分片存储方式）")]),a._v(" "),t("p",[a._v("将存储节点hash后放到一个圆上，然后将数据也hash后放到圆上，顺时针遇到的第一个节点就是数据存储节点")]),a._v(" "),t("p",[a._v("掉点或者增加节点只会影响顺时针后的下一个节点的数据，其他节点没有影响")]),a._v(" "),t("h3",{attrs:{id:"hash-槽-redis-官方集群分片方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash-槽-redis-官方集群分片方式","aria-hidden":"true"}},[a._v("#")]),a._v(" hash 槽 (REDIS  官方集群分片方式)")]),a._v(" "),t("p",[a._v("redis 集群中，一共 2 ^ 14 （16384）个槽位，每个MASTER节点拥有一个槽位区间（why 2^14?）")]),a._v(" "),t("p",[a._v("存储: key 根据crc-16(16位冗余校验) % 2 ^ 14 的值判断进入哪个槽区，从而知道在哪个节点")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/redis-slot.jpeg",alt:"SLOT"}})])])},[],!1,null,null,null);r.default=s.exports}}]);