(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{261:function(t,e,a){"use strict";a.r(e);var r=a(38),s=Object(r.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"io-多路复用-单线程多连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io-多路复用-单线程多连接","aria-hidden":"true"}},[t._v("#")]),t._v(" IO 多路复用 (单线程多连接)")]),t._v(" "),a("p",[t._v("举一个例子，模拟一个tcp服务器处理30个客户socket。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：")]),t._v(" "),a("ol",[a("li",[t._v("第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。")]),t._v(" "),a("li",[t._v("第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。")]),t._v(" "),a("li",[t._v("第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。")])]),t._v(" "),a("p",[t._v("这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。（例子出自"),a("a",{attrs:{href:"https://www.zhihu.com/question/28594409/answer/52835876",target:"_blank",rel:"noopener noreferrer"}},[t._v("知乎"),a("OutboundLink")],1),t._v("）")]),t._v(" "),a("h2",{attrs:{id:"select"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#select","aria-hidden":"true"}},[t._v("#")]),t._v(" SELECT")]),t._v(" "),a("p",[t._v("存储： 列表\n时间复杂度： O(n)")]),t._v(" "),a("p",[t._v("无差别轮询，SOCKET 越多，时间越长")]),t._v(" "),a("h2",{attrs:{id:"poll"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#poll","aria-hidden":"true"}},[t._v("#")]),t._v(" POLL")]),t._v(" "),a("p",[t._v("存储： 链表（个数无限制）\n时间复杂度： O(n)")]),t._v(" "),a("p",[t._v("无差别轮询，SOCKET 越多，时间越长")]),t._v(" "),a("h2",{attrs:{id:"epoll"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#epoll","aria-hidden":"true"}},[t._v("#")]),t._v(" EPOLL")]),t._v(" "),a("p",[t._v("存储： 链表（个数无限制）\n时间复杂度： O(1)")]),t._v(" "),a("p",[t._v("监听SOKET 事件放置到处理队列，无需轮询")])])},[],!1,null,null,null);e.default=s.exports}}]);